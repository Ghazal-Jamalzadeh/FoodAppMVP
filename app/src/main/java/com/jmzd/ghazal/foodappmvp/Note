http://color-name.com/
برای پیدا کردن رنگ ها از روی کد زنگ
پلاگینی به همین اسم هم برای اندروید استدیو وجود داره

NavController---------------------------------------------------------------------------------------
توی این پروژه یکم متفاوت کد زده شده براش چون باگ های قبلی رفع شده دیگه اسم تگ رو عوض نکردیم و ....
مثلا قبلا navController را جدا تعریف میکردیم الان تو دل navHost وجود داره.

Spinner---------------------------------------------------------------------------------------------
نکات طراحی اسپینر:
popupBackground :
ک گراند لایه ی پاپ آپ اسپینر است
overlapAnchor : false
برای اینکه وقتی محتوای پاپ آپ خیلی بزرگ است تمام صفحه نشود و از اسپینر به پایین باز شود
ولی مشکلی که هست اینه که اسپینر از بالای ویوی اصلی از میشه و روشو میپوشونه
android:dropDownVerticalOffset="50dp"
برای حل مشکل بالا

HTTP Errors------------------------------------------------------------------------------------------
200 -> success
500 -> server errors
ارورهای سری ۵۰۰ ارورهای سمت سرور هستن
مثلا سرور int میخواسته من string فرستادم و بک اند دولوپر هندل نکرده ترکیده
503:
سرور از بیخ پایننه و داون شده
400 ->
اشتباه از طرف ما
404 : not found
مثلا درخواست دادن به روتی که وجود ندارد
422 : validations
مثلا به جای ۱۱ رقم با ۳ رقم فرستادیم موبایل را


Extensions---------------------------------------------------------------------------------------
Rx-----------------------------------------------------------------------------------------------
اکستنشن نویسی روی آر ایکس
مشخص کردن تردهای Rx کار زمان بر و تکراری ایه.
میتونیم برای مدیریتیش اکستنشن بنویسیم
همچچنین میتونیم برای چک کردن اینترنت که در همه صفحات داریم هم اکستنشن بنویسیم

fun <T : Any> Single<T>.applyScheduler(scheduler: Scheduler): Single<T> =
    subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread())

fun <T : Any> : یعنی این فانکشن از نوع جنریک است

Single : روی چه چیزی قراره سوار شه این اکستنشن؟ روی سینگل.
چرا سینگل؟ چون توی فایل apiServices داریم از سینگل استفاده میکنیم
اگر مثلا observable یا چیز دیگری بود همون رو مینوشتیم

Single<T> : نوع دیتا تایپ این سینگل را از نوع جنریک میدیم که خودمون رو محدود نکنیم

applyScheduler : اسم دلخواهی که برای اکستنشن در نظر گرفتیم

(scheduler: Scheduler) : توی ورودی اسکجولر مورد نظر را از کاربر میگیریم

: Single<T> : دیتایی هم که برمیگردونه یک سینگل از نوع جنریک است



fun <T : Any> Single<T>.applyIoScheduler() = applyScheduler(Schedulers.io())
چون میخوایم به صورت پیش فرض io را بهش داده باشیم پس این اکستنشن رو مینویسیم برای این کار

check connectivity---------------------------------------------------------------------------------
اکتنشن مربوط به چک کردن اینترنت:
البته بهترین راه چک کردن اینترنت همون روشی هست که توی لایو دیتا یاد گرفتیم
این روش یکم ارورهای deprication میده ولی در اجرا مشکلی نداره

fun Context.isNetworkAvailable(): Boolean {
    val cm = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    val info = cm.activeNetworkInfo
    return info != null && info.isConnected
}

روی کانتکس سوار میشه
اسم اکستنشن isNetworkAvailable هست
خروجی اون یک boolean هست

برای چک کردن اینترنت به دو تا چیز نیز داریم
1- ConnectivityManager
2- NetworkInfo

getSystemService :
اندروید سرویس های مختلفی داره. مثلا دسسترسی به درصد باتری
دسترسی به درصد اینترنت هم  از طریق این سرویس ها انجام میشه

(Context.CONNECTIVITY_SERVICE)
میایم CONNECTIVITY_SERVICE را از "کلاس" میگیریم
نگید از this استفاده کن خب کانتکس هست. این کلاس کانتکسه و فرق داره

as ConnectivityManager
بعد تبدیلش میکنیم به ConnectivityManager

val info = cm.activeNetworkInfo
بعد میایم از این ConnectivityManager که داریم activeNetworkInfo رو میخونیم

چون وضعیت اینترنت رو میخوایم چک کنیم با دسترسی ACCESS_NETWORK_STATE رو هم بگیریم توی مانیفست

app development levels-----------------------------------------------------------------------------
1-
میایم contract مربوط به اون صفه را تعریف میکنیم

2-
وابستگی های مربوط به ویو را تعریف میکنیم توی فایل di

3-
از وابستگی ای که تعریف کردیم میایم توی فرگمنت  یا اکتیویتی ارث بری میکنیم
متدهای مربوطه را implement میکنیم
متدهای موجود در base هم در اینجا override می شوند

notice----------------------------------------------------------------------------------------------
empty : لیست وجود دارد ولی خالی است
null : اصلا ممکن است فیلدی به اون نام برنگشته باشه برای ما

RxNetwork-------------------------------------------------------------------------------------------
یک لایبرری خیلی عالی برای چک کردن اتصال اینترنت به صورت real time
قبلا یک روش برای این کار یاد گرفته بودیم با لایو دیتا
این مثل همون عمل میکنه ولی با RX
فقط نکته ای که داره اینه که از Rx 2 داره استفاده میکنه
ولی ما از Rx 3 داریم استفاده میکنه که بازم فرقی به حال ما نمیکنه
فقط موقع معرفی schedulers ها باید حواسمون باشه
که از نسخه ۲ بهش معرفی کنیم نه از نسخه ۳
دیگه نیاز به هندل کردن چیزی نیست
و چون به صورت ری اکتیو x است فرقی نداره کجای صفحه کدش رو بزنید. در هر صورت اجرا میشه
اگه داکیومنتش رو بخونیید گفته که هم میتونید داخل کلاس اپلیکیشن تعریفش کنید inject کنید و استفاده کنید هم داخل اکتیویتی یا فرگمنت
کد همه ش به صورت کامل داخل گیت هاب هست

باگ کتابخونه:
همیشه از اولین تغییر وضعیت اینترنت شروع میکنه به کار کردن
پس تو حالت دیفالت شروع به کار اپلیکیشن چک نمیکنه اینترنت را و ما به اکسستنشن خودمون نیاز پیدا میکنیم

json converter--------------------------------------------------------------------------------------
میخوایم توی این اپ یک بخش هایی از جیسون رو به صورت دستی از کنیم:
برای دریافت جیسون باید چیکار کنیم؟
چیزی که دریافت میکنیم را باید توسط Gson بیایم
یادآوری از فصل رتروفیت:
ما توی رتروفیت توسط Gson میایم جیسون رو میگیریم
و این جیسون رو توسط Gson برای رتروفیت تبدیل به یک چیز قابل فهمی میکنیم
پس من الان این اطلاعات را در قالب Gson دارم
(مدلی که داریم و Gson برامون ساخته منظوره)
برای تبدیل این مدل به جیسون باید چیکار کنیم؟
JSONObject(Gson().toJson(model))

youtube player--------------------------------------------------------------------------------------
برای اینکه بتونیم یوتیوب پلیر را در اپلیکیشن خودمون داشته باشیم نیاز به یک api key داریم.
برای به دست آوردن این api key باید وارد console.cloud.google.com شوید.
با vpn میرید و با gmail تون وارد میشید.
بعد یک new project میسازید
my project -> new project -> projectName : FoodAppYoutubePlayer -> create -> select project ->
navigation menu -> api & services -> enable api & services ->
برای اینکه بتونیم اون حالت api هاش رو برای اپلیکیشن خودمون فعال کنیم
توی صفحه جدیدی که لود میشه
+ enable api's and services -> اینجا سرویس های خیلی متنوع و جالبی داره
search box -> youtube data api v3 -> select -> enable
new page -> left menu -> credentials  -> + create credentials -> api key -> copy
حالا api key که به دست آوردیم را میبریم توی constants نگه میداریم

اضافه کرپم کتابخونه یوتیوب به پروژه:
developers.google.com/youtube/android/player/downloads
مثل دپندنسی های دیگه implementation نداره و به صورت فایل jar هست
فایل زیپ رو اکسترکت کنید و فایل jar رو استخراج کنید
copy jar file -> open android studio -> project view -> open your project -> app -> libs -> paste jar file
محل قرار گیری کتابخونه ها ی jar ست
android view -> gradle -> implementation files('libs/YouTubeAndroidPlayerApi.jar')

اکتویتی:
برای استفاده از یوتیوب پلیر نیاز به یک اکتیویتی داریم
برخلاف سایر اکتیویتی ها از AppCompatAActivity ارث بری نمیکنه و از YouTubeBaseActivity ارث بری میکنه
به همین علت باید از اکتیویتی استفاده کنیم
چرا توی پکیج detail قرارش میدیم؟
چون تنها راه ارتباط با صفحه پلیر فقط و فقط از صفحه detail عه

خط کد زیر را در مانیفست این اکتیویتی اضافه میکنیم که به صورت خودکار بچرخه
android:screenOrientation="sensorLandscape"
اگه landscape خالی بزنیم هم میچرخه
 ولی فرق sensorLandscape اینه که از سنسور خود گوشی استفاده میکنه
 و کاربر گوشی را به هر طرف بچرخونه به همون طرف میچرخه

نکته خیلی مهم:
زمانی که از این کتابخونه استفاده میکنیم باید یک کوءری به مانیفست اضافه کنیم
برای run کردن سرویس یوتیوب هست این کوءری

برای initialize کردن این یوتیوب پلیر نیاز به دو تا چیز اصلی داریم:
اولی api key که ساختیم
دوم نیاز به یک listener داریم که در این listener دو تا وضعیت رو به ما میده
1 : همه چیز اوکی و آماده اجرا شدن است و برو کاراشو انجام بده
2 : با ارور رو به رو شده و به کاربر این ارور رو نشون بده

شناسه ویدیو:
این ویدیو پلیر یوتیوب برای پلی کردن ویدیو نیاز به url کامل ندارد. بلکه نیاز به شناسه ویدیو دارد
که خومون میتونیم با پردازش string و متد split استخراج کنیم شناسه رو






